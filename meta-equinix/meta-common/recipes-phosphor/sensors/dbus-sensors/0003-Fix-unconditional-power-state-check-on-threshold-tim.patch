From 2f0293cdfe8df79502a7021e0b89b19990c131ef Mon Sep 17 00:00:00 2001
From: Zev Weiss <zev@bewilderbeest.net>
Date: Wed, 17 Feb 2021 00:25:13 -0600
Subject: [PATCH] Fix unconditional power-state check on threshold timer
 expiration

Not all sensors set up the power-state match, and hence aren't prepared
to call isPowerOn(), but the timer callback in ThresholdTimer::startTimer()
called it unconditionally regardless of the sensor's readState,
resulting in runtime error exceptions.

We now check sensor->readingStateGood() instead of directly checking
power state, which takes readState into account.  Due to the fact that
Threshold.hpp is included in sensor.hpp and hence can't (usefully)
include sensor.hpp, this entails moving the definition of startTimer()
into Threshold.cpp instead.
---
 include/Thresholds.hpp | 47 ++-------------------------------------
 src/Thresholds.cpp     | 50 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 51 insertions(+), 46 deletions(-)

diff --git a/include/Thresholds.hpp b/include/Thresholds.hpp
index ca2b0a0b89bf..4920a9997f0c 100644
--- a/include/Thresholds.hpp
+++ b/include/Thresholds.hpp
@@ -99,51 +99,8 @@ struct ThresholdTimer
         }
     }
 
-    void startTimer(const Threshold& threshold, bool assert, double assertValue)
-    {
-        struct TimerUsed timerUsed = {};
-        constexpr const size_t waitTime = 5;
-        TimerPair* pair = nullptr;
-
-        for (TimerPair& timer : timers)
-        {
-            if (!timer.first.used)
-            {
-                pair = &timer;
-                break;
-            }
-        }
-        if (pair == nullptr)
-        {
-            pair = &timers.emplace_back(timerUsed,
-                                        boost::asio::deadline_timer(io));
-        }
-
-        pair->first.used = true;
-        pair->first.level = threshold.level;
-        pair->first.direction = threshold.direction;
-        pair->first.assert = assert;
-        pair->second.expires_from_now(boost::posix_time::seconds(waitTime));
-        pair->second.async_wait([this, pair, threshold, assert,
-                                 assertValue](boost::system::error_code ec) {
-            pair->first.used = false;
-
-            if (ec == boost::asio::error::operation_aborted)
-            {
-                return; // we're being canceled
-            }
-            else if (ec)
-            {
-                std::cerr << "timer error: " << ec.message() << "\n";
-                return;
-            }
-            if (isPowerOn())
-            {
-                assertThresholds(sensor, assertValue, threshold.level,
-                                 threshold.direction, assert);
-            }
-        });
-    }
+    void startTimer(const Threshold& threshold, bool assert, double assertValue,
+                    Sensor* sensor);
 
     boost::asio::io_service& io;
     std::list<TimerPair> timers;
diff --git a/src/Thresholds.cpp b/src/Thresholds.cpp
index f4d4ed05e43c..694efb5bfa55 100644
--- a/src/Thresholds.cpp
+++ b/src/Thresholds.cpp
@@ -381,7 +381,7 @@ void checkThresholdsPowerDelay(Sensor* sensor, ThresholdTimer& thresholdTimer)
                                        change.threshold, !change.asserted))
             {
                 thresholdTimer.startTimer(change.threshold, change.asserted,
-                                          change.assertValue);
+                                          change.assertValue, sensor);
                 continue;
             }
         }
@@ -529,4 +529,52 @@ bool hasWarningInterface(
     }
     return false;
 }
+
+void ThresholdTimer::startTimer(const Threshold& threshold, bool assert,
+                                double assertValue, Sensor* sensor)
+{
+    struct TimerUsed timerUsed = {};
+    constexpr const size_t waitTime = 5;
+    TimerPair* pair = nullptr;
+
+    for (TimerPair& timer : timers)
+    {
+        if (!timer.first.used)
+        {
+            pair = &timer;
+            break;
+        }
+    }
+    if (pair == nullptr)
+    {
+        pair = &timers.emplace_back(timerUsed,
+                                    boost::asio::deadline_timer(io));
+    }
+
+    pair->first.used = true;
+    pair->first.level = threshold.level;
+    pair->first.direction = threshold.direction;
+    pair->first.assert = assert;
+    pair->second.expires_from_now(boost::posix_time::seconds(waitTime));
+    pair->second.async_wait([this, pair, threshold, assert,
+                             assertValue, sensor](boost::system::error_code ec) {
+        pair->first.used = false;
+
+        if (ec == boost::asio::error::operation_aborted)
+        {
+            return; // we're being canceled
+        }
+        else if (ec)
+        {
+            std::cerr << "timer error: " << ec.message() << "\n";
+            return;
+        }
+        if (sensor->readingStateGood())
+        {
+            assertThresholds(sensor, assertValue, threshold.level,
+                             threshold.direction, assert);
+        }
+    });
+}
+
 } // namespace thresholds
-- 
2.17.1

